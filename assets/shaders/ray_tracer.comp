#version 460

// MARK: Config

#define EPS 0.001

#define SPP 20
#define MAX_BOUNCES 30
#define RAY_T_MIN 0.01
#define RAY_T_MAX 1000.0
#define RR_PROBABILITY 1.0 // FIXME: High artifacts

#define SPHERE_BUFFER_MAX 100
#define POINT_LIGHT_BUFFER_MAX 10

#define MATERIAL_LAMBERTIAN 0
#define MATERIAL_METAL 1
#define MATERIAL_DIELECTRIC 2

// MARK: Scene D.S.

layout(
    local_size_x = 8,
    local_size_y = 8,
    local_size_z = 1
) in;

// MARK: * Camera

struct Camera {
    vec3 position;
    vec3 up;
    vec3 look_at;
    float t_near;
    float t_far;
    float vertical_fov;
};

layout(push_constant) uniform PushConstant {
    Camera camera;
    float time;
} push_constant_data;

Camera u_camera = push_constant_data.camera;
float u_time = push_constant_data.time;

// MARK: * Img & Lens

layout(set = 0, binding = 0) uniform writeonly image2D img; // 不能加rgba8，否则会因为格式不兼容而运行时错误

layout(set = 0, binding = 1) uniform LengthBuffer {
    uint spheres;
    uint point_lights;
} lens;

// MARK: * Sphere

struct Sphere {
    vec3 center;
    float radius;
    uint material;
};

layout(set = 0, binding = 2) uniform SphereBuffer {
    Sphere sphere[SPHERE_BUFFER_MAX];
} spheres;

// MARK: * Point Light

struct PointLight {
    vec3 position;
    vec3 energy;
};

layout(set = 0, binding = 3) uniform PointLightBuffer {
    PointLight point_light[POINT_LIGHT_BUFFER_MAX];
} point_lights;

// MARK: * Material

// albedo at index 0, because of aligement requirements
struct Material {
    vec3 albedo;
    uint ty;
    float fuzz;
    float refraction_ratio;
};

layout(set = 0, binding = 4) uniform MaterialBuffer {
    Material material[SPHERE_BUFFER_MAX];
} materials;

// MARK: Ray Tracing D.S.

struct Ray {
    vec3 origin;
    vec3 direction;
    float t_min;
    float t_max;
};

struct Interaction {
    float time;
    vec3 position;
    vec3 normal;
    // vec3 tangent;
    // vec3 bitangent;
    // vec2 tex_coord;
    // In Moer-Lite, there are a lot of dxxx, I don't know what it is.
    uint material_id;
    bool is_normal_outward;
};

// MARK: Func: Utils

float length2(in vec3 v) {
    return dot(v, v);
}

// MARK: Func: Random

// all random function's range is [0, 1)

// default random
// g_rand_seed should be near 1-100; And this constant should be useless, just a default value
float g_rand_seed = 19.260817;
float g_rand_index = 0.0; // to make a random sequence
void srand(float time, vec2 uv) {
    g_rand_seed = fract(fract(sin(time) * 43758.5453) + fract(sin(uv.x) * 22578.5453) + fract(sin(uv.y) * 114514.1919));
}
float _rand(float x) {
    return fract(sin(x) * 43758.5453);
}
float rand() {
    g_rand_index += 1.0;
    return _rand(g_rand_seed + g_rand_index);
}
vec2 rand2() {
    return vec2(rand(), rand());
}
vec3 rand3() {
    return vec3(rand(), rand(), rand());
}

// MARK: * Random with Seed

// specific seed random (input float)
float rand_v1(float seed) {
    return _rand(seed);
}
vec2 rand2_v1(float seed) {
    return vec2(rand_v1(seed), rand_v1(seed + 1.0));
}
vec3 rand3_v1(float seed) {
    return vec3(rand_v1(seed), rand_v1(seed + 1.0), rand_v1(seed + 2.0));
}

// specific seed random (input vec2)
float rand_v2(vec2 seed) {
    return _rand(dot(seed, vec2(12.9898, 78.233)));
}
vec2 rand2_v2(vec2 seed) {
    return vec2(rand_v2(seed), rand_v2(seed + vec2(1.0)));
}
vec3 rand3_v2(vec2 seed) {
    return vec3(rand_v2(seed), rand_v2(seed + vec2(1.0)), rand_v2(seed + vec2(2.0)));
}

// advanced random
vec3 random_in_unit_sphere() {
    vec3 p;
    do {
        p = 2.0 * rand3() - vec3(1.0);
    } while(dot(p, p) >= 1.0);
    return p;
}

vec3 random_in_unit_sphere_surface() {
    return normalize(random_in_unit_sphere());
}

vec3 random_in_unit_hemisphere(in vec3 normal) {
    vec3 in_unit_sphere = random_in_unit_sphere();
    return dot(in_unit_sphere, normal) > 0.0 ? in_unit_sphere : -in_unit_sphere;
}

vec3 random_in_unit_hemisphere_surface(in vec3 normal) {
    return normalize(random_in_unit_hemisphere(normal));
}

// MARK: Func: Sample Ray
Ray sample_ray(in vec2 uv, in vec2 size) {
    float h = 2.0 * u_camera.t_near * tan(u_camera.vertical_fov / 2.0);
    float w = h * size.x / size.y;

    vec3 look_at_dir = normalize(u_camera.look_at - u_camera.position);
    vec3 u = normalize(cross(look_at_dir, u_camera.up)) * w; // right_dir with length
    vec3 v = normalize(cross(look_at_dir, u)) * h; // down_dir with length

    vec3 pos = u_camera.position + look_at_dir * u_camera.t_near;
    vec3 uv_pos = pos + u * (uv.x - 0.5) + v * (uv.y - 0.5);

    float t_coef = length(uv_pos - u_camera.position) / length(pos - u_camera.position);

    return Ray (
        u_camera.position,
        normalize(uv_pos - u_camera.position),
        u_camera.t_near * t_coef,
        u_camera.t_far * t_coef
    );
}

// MARK: Func: Intersection
bool is_intersect_with_quadratic_equation(
    in float a,
    in float b,
    in float c,
    in Ray ray,
    out Interaction interaction
) {
    float delta = b * b - 4.0 * a * c;
    if (sign(delta) < 0.0) return false;
    float sqrt_delta = sqrt(delta);
    float t0 = (-b + sqrt_delta) / (2.0 * a);
    float t1 = (-b - sqrt_delta) / (2.0 * a);
    if (t0 > t1) { float tmp = t0; t0 = t1; t1 = tmp; }

    if (ray.t_min <= t0 && t0 <= ray.t_max) {
        interaction = Interaction(
            t0,
            ray.origin + ray.direction * t0,
            vec3(0.0),
            0,
            true
        );
        return true;
    }

    if (ray.t_min <= t1 && t1 <= ray.t_max) {
        interaction = Interaction(
            t1,
            ray.origin + ray.direction * t1,
            vec3(0.0),
            0,
            true
        );
        return true;
    }

    return false;
}

bool is_intersect_with_sphere(
    in Ray ray,
    in Sphere sphere,
    out Interaction interaction
) {
    vec3 co = ray.origin - sphere.center;
    float a = dot(ray.direction, ray.direction);
    float b = 2.0 * dot(ray.direction, co);
    float c = dot(co, co) - sphere.radius * sphere.radius;

    if (is_intersect_with_quadratic_equation(a, b, c, ray, interaction)) {
        interaction.normal = normalize(interaction.position - sphere.center);
        interaction.material_id = sphere.material;
        if (length2(ray.origin - sphere.center) < sphere.radius * sphere.radius) {
            interaction.normal = -interaction.normal;
            interaction.is_normal_outward = false;
        }
        return true;
    } else {
        return false;
    }
}

Interaction get_intersection_with_scene(
    Ray ray
) {
    Interaction inter;
    inter.time = ray.t_max + 1.0;
    for (uint i = 0; i < lens.spheres; i++) {
        Interaction new_inter;
        if (is_intersect_with_sphere(ray, spheres.sphere[i], new_inter)) {
            if (new_inter.time <= ray.t_max) {
                ray.t_max = new_inter.time;
                inter = new_inter;
            }
        }
    }
    return inter;
}

// MARK: Func: Material Scatter

// PlaceHolder
// PlaceHolder
// PlaceHolder

// MARK: * Lambertian

void lambertian_scatter(
    in Material material,
    in Ray ray,
    in Interaction inter,
    out vec3 attenuation, // color
    out Ray new_ray
) {
    vec3 direction = normalize(inter.normal + random_in_unit_sphere_surface()); // BRDF Sampling here
    // vec3 direction = random_in_unit_hemisphere_surface(inter.normal); // BRDF Sampling here

    if (direction.x < EPS && direction.y < EPS && direction.z < EPS) { direction = inter.normal; }

    // return
    attenuation = material.albedo;
    new_ray = Ray(
        inter.position,
        direction,
        RAY_T_MIN,
        RAY_T_MAX
    );
}

// MARK: * Metal

void metal_scatter(
    in Material material,
    in Ray ray,
    in Interaction inter,
    out vec3 attenuation, // color
    out Ray new_ray
) {
    // |reflected ray| == |ray.direction|
    // I don't prove it, but I proved the reflected ray is normalized when the input ray is normalized
    vec3 reflected = reflect(ray.direction, inter.normal);
    if (dot(reflected, inter.normal) < 0.0) { reflected = -reflected; }
    vec3 direction;
    do {
        direction = normalize(reflected + material.fuzz * random_in_unit_sphere_surface());
    } while (dot(direction, inter.normal) < 0.0);

    attenuation = material.albedo;
    new_ray = Ray(
        inter.position,
        direction,
        RAY_T_MIN,
        RAY_T_MAX
    );
}

// MARK: * Dielectric

float fresnel_schlick(
    in float cosine,
    in float refraction_ratio
) {
    float r0 = (1.0 - refraction_ratio) / (1.0 + refraction_ratio);
    r0 = r0 * r0;
    return r0 + (1.0 - r0) * pow(1.0 - cosine, 5.0);
}

void dielectric_scatter(
    in Material material,
    in Ray ray,
    in Interaction inter,
    out vec3 attenuation, // color
    out Ray new_ray
) {
    float refraction_ratio = inter.is_normal_outward ? (1.0 / material.refraction_ratio) : material.refraction_ratio;

    float cos_theta = dot(-ray.direction, inter.normal);
    float sin_theta = sqrt(1.0 - cos_theta * cos_theta);

    bool is_refracted = refraction_ratio * sin_theta <= 1.0;

    vec3 refracted;
    if (is_refracted && (rand() >= fresnel_schlick(cos_theta, refraction_ratio))) {
        refracted = refract(ray.direction, inter.normal, refraction_ratio);
    } else {
        refracted = reflect(ray.direction, inter.normal);
    }

    attenuation = vec3(1.0);
    new_ray = Ray(
        inter.position,
        refracted,
        RAY_T_MIN,
        RAY_T_MAX
    );
}

// MARK: * Material

void material_scatter(
    in Material material,
    in Ray ray,
    in Interaction inter,
    out vec3 attenuation, // color
    out Ray new_ray
) {
    if (material.ty == MATERIAL_LAMBERTIAN) { // diffuse
        lambertian_scatter(material, ray, inter, attenuation, new_ray);

    } else if (material.ty == MATERIAL_METAL) { // glossy
        metal_scatter(material, ray, inter, attenuation, new_ray);

    } else if (material.ty == MATERIAL_DIELECTRIC) { // specular / refractive
        dielectric_scatter(material, ray, inter, attenuation, new_ray);

    }
}

// MARK: Func: Trace Ray

vec3 sample_infinite_light(
    in Ray ray
) {
    float a = 0.5 * (ray.direction.y + 1.0);
    return mix(vec3(1.0), vec3(0.5, 0.7, 1.0), a);
}

vec3 trace_ray(
    in Ray ray // ray is not `in`. This is because t_min will be modified
) {
    vec3 color = vec3(0.0);
    vec3 attenuation = vec3(1.0);
    uint left_bounces = MAX_BOUNCES;
    uint path_reuse_count = 0;
    while(left_bounces > 0) {
        left_bounces -= 1;

        // 1. get intersection
        Interaction inter = get_intersection_with_scene(ray);

        // miss
        if (inter.time > ray.t_max) {
            color += attenuation * sample_infinite_light(ray);
            path_reuse_count += 1;
            break;
        }

        // 2. attenuation & new ray
        Material material = materials.material[inter.material_id];
        vec3 new_attenuation = vec3(0.0, 0.0, 0.0);
        Ray new_ray;
        material_scatter(material, ray, inter, new_attenuation, new_ray);
        attenuation *= new_attenuation;
        ray = new_ray;
        ray.origin += ray.direction * RAY_T_MIN; // make sure ray won't hit its origin

        // is black
        if (attenuation.r < EPS && attenuation.g < EPS && attenuation.b < EPS) {
            path_reuse_count += 1;
            break;
        }

        // TODO: cosine term

        // 3. sample lights (if diffuse or glossy)
        if (material.ty == MATERIAL_LAMBERTIAN) {
            // color += attenuation * sample_infinite_light(ray);
            // path_reuse_count += 1;

        } else if (material.ty == MATERIAL_METAL) {
            // color += attenuation * sample_infinite_light(ray);
            
        }

        if (rand() >= RR_PROBABILITY) {
            break;
        } else {
            attenuation /= RR_PROBABILITY;
        }
    }

    if (path_reuse_count > 0) { // make sure energy conservation
        color /= float(path_reuse_count);
    }

    return color;
}

// MARK: Main

void main() {
    vec2 window_size = vec2(imageSize(img));
    vec2 uv = (gl_GlobalInvocationID.xy + vec2(0.5)) / window_size;
    srand(u_time, uv);

    Ray ray = sample_ray(uv, window_size);

    uint len = lens.spheres;
    float r = spheres.sphere[0].radius;
    vec3 pos = point_lights.point_light[0].position;
    float a = materials.material[0].refraction_ratio;

    vec3 color = vec3(0.0);
    for (uint i = 0; i < SPP; i++) {
        color += trace_ray(ray);
    }
    color /= float(SPP);

    imageStore(img, ivec2(gl_GlobalInvocationID.xy), vec4(color, 1.0));
}