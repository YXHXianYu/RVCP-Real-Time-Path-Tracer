#version 460

// MARK: Config

#define SPP 10
#define MAX_BOUNCES 20
#define ATTENUATION_EPS 0.001

#define SPHERE_BUFFER_MAX 100
#define POINT_LIGHT_BUFFER_MAX 10

#define MATERIAL_LAMBERTIAN 0
#define MATERIAL_METAL 1
#define MATERIAL_DIELECTRIC 2

// MARK: Scene D.S.

layout(
    local_size_x = 8,
    local_size_y = 8,
    local_size_z = 1
) in;

// MARK: * Camera

layout(push_constant) uniform Camera {
    vec3 position;
    vec3 up;
    vec3 look_at;
    float t_near;
    float t_far;
    float vertical_fov;
} camera;

// MARK: * Img & Lens

layout(set = 0, binding = 0) uniform writeonly image2D img; // 不能加rgba8，否则会因为格式不兼容而运行时错误

layout(set = 0, binding = 1) uniform LengthBuffer {
    uint spheres;
    uint point_lights;
} lens;

// MARK: * Sphere

struct Sphere {
    vec3 center;
    float radius;
    uint material;
};

layout(set = 0, binding = 2) uniform SphereBuffer {
    Sphere sphere[SPHERE_BUFFER_MAX];
} spheres;

// MARK: * Point Light

struct PointLight {
    vec3 position;
    vec3 energy;
};

layout(set = 0, binding = 3) uniform PointLightBuffer {
    PointLight point_light[POINT_LIGHT_BUFFER_MAX];
} point_lights;

// MARK: * Material

// albedo at index 0, because of aligement requirements
struct Material {
    vec3 albedo;
    uint ty;
    float fuzz;
    float index_of_refraction;
};

layout(set = 0, binding = 4) uniform MaterialBuffer {
    Material material[SPHERE_BUFFER_MAX];
} materials;

// MARK: Ray Tracing D.S.

struct Ray {
    vec3 origin;
    vec3 direction;
    float t_min;
    float t_max;
};

struct Interaction {
    float time;
    vec3 position;
    vec3 normal;
    // vec3 tangent;
    // vec3 bitangent;
    // vec2 tex_coord;
    // In Moer-Lite, there are a lot of dxxx, I don't know what it is.
    uint material_id;
};

// MARK: Func: Utils

// MARK: Func: Sample Ray
Ray sample_ray(in vec2 uv, in vec2 size) {
    float h = 2.0 * camera.t_near * tan(camera.vertical_fov / 2.0);
    float w = h * size.x / size.y;

    vec3 look_at_dir = normalize(camera.look_at - camera.position);
    vec3 u = normalize(cross(look_at_dir, camera.up)) * w; // right_dir with length
    vec3 v = normalize(cross(look_at_dir, u)) * h; // down_dir with length

    vec3 pos = camera.position + look_at_dir * camera.t_near;
    vec3 uv_pos = pos + u * (uv.x - 0.5) + v * (uv.y - 0.5);

    float t_coef = length(uv_pos - camera.position) / length(pos - camera.position);

    return Ray (
        camera.position,
        normalize(uv_pos - camera.position),
        camera.t_near * t_coef,
        camera.t_far * t_coef
    );
}

// MARK: Func: Intersection
bool is_intersect_with_quadratic_equation(
    in float a,
    in float b,
    in float c,
    in Ray ray,
    out Interaction interaction
) {
    float delta = b * b - 4.0 * a * c;
    if (sign(delta) < 0.0) return false;
    float sqrt_delta = sqrt(delta);
    float t0 = (-b + sqrt_delta) / (2.0 * a);
    float t1 = (-b - sqrt_delta) / (2.0 * a);
    bool is_intersect = false;

    if (t0 >= ray.t_min && t0 <= ray.t_max) {
        interaction = Interaction(
            t0,
            ray.origin + ray.direction * t0,
            vec3(0.0),
            0
        );
        return true;
    }

    if (t1 >= ray.t_min && t1 <= ray.t_max) {
        interaction = Interaction(
            t1,
            ray.origin + ray.direction * t1,
            vec3(0.0),
            0
        );
        return true;
    }

    return false;
}

bool is_intersect_with_sphere(
    in Ray ray,
    in Sphere sphere,
    out Interaction interaction
) {
    vec3 co = ray.origin - sphere.center;
    float a = dot(ray.direction, ray.direction);
    float b = 2.0 * dot(ray.direction, co);
    float c = dot(co, co) - sphere.radius * sphere.radius;

    if (is_intersect_with_quadratic_equation(a, b, c, ray, interaction)) {
        interaction.normal = normalize(interaction.position - sphere.center);
        interaction.material_id = sphere.material;
        return true;
    } else {
        return false;
    }
}

Interaction get_intersection_with_scene(
    in Ray ray
) {
    Interaction inter;
    inter.time = ray.t_max + 1.0;
    for (uint i = 0; i < lens.spheres; i++) {
        Interaction new_inter;
        if (is_intersect_with_sphere(ray, spheres.sphere[i], new_inter)) {
            if (new_inter.time < ray.t_max) {
                ray.t_max = new_inter.time;
                inter = new_inter;
            }
        }
    }
    return inter;
}

// MARK: Func: Material Scatter

// MARK: * Lambertian

void lambertian_scatter(
    in Material material,
    in Ray ray,
    in Interaction inter,
    out vec3 attenuation, // color
    out Ray new_ray
) {
    attenuation = material.albedo;
    new_ray.origin = inter.position;
    new_ray.direction = inter.normal;
}

// MARK: * Metal

void metal_scatter(
    in Material material,
    in Ray ray,
    in Interaction inter,
    out vec3 attenuation, // color
    out Ray new_ray
) {

}

// MARK: * Dielectric

void dielectric_scatter(
    in Material material,
    in Ray ray,
    in Interaction inter,
    out vec3 attenuation, // color
    out Ray new_ray
) {

}

// MARK: * Material

void material_scatter(
    in Material material,
    in Ray ray,
    in Interaction inter,
    out vec3 attenuation, // color
    out Ray new_ray
) {
    if (material.ty == MATERIAL_LAMBERTIAN) { // diffuse
        lambertian_scatter(material, ray, inter, attenuation, new_ray);

    } else if (material.ty == MATERIAL_METAL) { // glossy
        metal_scatter(material, ray, inter, attenuation, new_ray);

    } else if (material.ty == MATERIAL_DIELECTRIC) { // specular / refractive
        dielectric_scatter(material, ray, inter, attenuation, new_ray);

    } else {
    }
}

// MARK: Func: Trace Ray

vec3 sample_infinite_light(
    in Ray ray
) {
    float a = 0.5 * (ray.direction.y + 1.0);
    return mix(vec3(1.0), vec3(0.5, 0.7, 1.0), a);
}

vec3 trace_ray(
    Ray ray // ray is not `in`. This is because t_min will be modified
) {
    vec3 color = vec3(0.0);
    vec3 attenuation = vec3(1.0);
    uint left_bounces = MAX_BOUNCES;
    uint path_reuse_count = 0;
    while(left_bounces > 0) {
        left_bounces -= 1;

        if (max(attenuation.r, max(attenuation.g, attenuation.b)) < ATTENUATION_EPS) { break; }
        if (ray.t_max < ray.t_min) { break; }

        // 1. get intersection
        Interaction inter = get_intersection_with_scene(ray);

        // miss
        if (inter.time > ray.t_max) {
            color += attenuation * sample_infinite_light(ray);
            path_reuse_count += 1;
            break;
        }

        // 2. attenuation & new ray
        Material material = materials.material[inter.material_id];
        vec3 new_attenuation = vec3(1.0, 0.0, 0.0);
        Ray new_ray = Ray(vec3(0.0), vec3(0.0), -1.0, -2.0); // t_max < t_min
        material_scatter(material, ray, inter, new_attenuation, new_ray);
        attenuation *= new_attenuation;
        ray = new_ray;

        // 3. sample lights (if diffuse or glossy)
        if (material.ty == MATERIAL_LAMBERTIAN) {
            color += attenuation * sample_infinite_light(ray);
            path_reuse_count += 1;

        } else if (material.ty == MATERIAL_METAL) {
            // color += attenuation * sample_infinite_light(ray);
            
        }
    }

    if (path_reuse_count > 0) { // make sure energy conservation
        color /= float(path_reuse_count);
    }

    return color;
}

// MARK: Main

void main() {
    // 1. Sample Ray
    vec2 window_size = vec2(imageSize(img));
    vec2 uv = (gl_GlobalInvocationID.xy + vec2(0.5)) / window_size;
    Ray ray = sample_ray(uv, window_size);

    uint len = lens.spheres;
    float r = spheres.sphere[0].radius;
    vec3 pos = point_lights.point_light[0].position;
    float a = materials.material[0].index_of_refraction;

    vec3 color = vec3(0.0);
    for (uint i = 0; i < SPP; i++) {
        color += trace_ray(ray);
    }
    color /= float(SPP);

    imageStore(img, ivec2(gl_GlobalInvocationID.xy), vec4(color, 1.0));
}